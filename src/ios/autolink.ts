import fs from 'fs';
import path from 'path';

const autolink = () => {
    // --- Interfaces ---
    interface TamerConfig {
        ios?: {
            podspecPath?: string;
            moduleClassName?: string;
        };
    }

    interface DiscoveredPackage {
        name: string;
        config: TamerConfig;
        packagePath: string;
    }

    // --- Configuration Loading ---
    let appName: string;
    try {
        const configPath = path.join(process.cwd(), 'tamer.config.json');
        if (!fs.existsSync(configPath)) {
            throw new Error('tamer.config.json not found in the project root.');
        }
        const configRaw = fs.readFileSync(configPath, 'utf8');
        const config = JSON.parse(configRaw);
        appName = config.ios?.appName;

        if (!appName) {
            throw new Error('"ios.appName" must be defined in tamer.config.json');
        }
    } catch (error: any) {
        console.error(`‚ùå Error loading configuration: ${error.message}`);
        process.exit(1);
    }

    // --- Constants & Paths ---
    const projectRoot = process.cwd();
    const nodeModulesPath = path.join(projectRoot, 'node_modules');
    const iosProjectPath = path.join(projectRoot, 'ios');

    // --- Core Logic ---

    function updateGeneratedSection(filePath: string, newContent: string, startMarker: string, endMarker: string): void {
        if (!fs.existsSync(filePath)) {
            console.warn(`‚ö†Ô∏è File not found, skipping update: ${filePath}`);
            return;
        }

        let fileContent = fs.readFileSync(filePath, 'utf8');
        const escapedStartMarker = startMarker.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const escapedEndMarker = endMarker.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        const regex = new RegExp(`${escapedStartMarker}[\\s\\S]*?${escapedEndMarker}`, 'g');
        const replacementBlock = `${startMarker}\n${newContent}\n${endMarker}`;

        if (regex.test(fileContent)) {
            fileContent = fileContent.replace(regex, replacementBlock);
        } else {
            console.warn(`‚ö†Ô∏è Could not find autolink markers in ${path.basename(filePath)}. Appending to the end of the file.`);
            fileContent += `\n${replacementBlock}\n`;
        }

        fs.writeFileSync(filePath, fileContent);
        console.log(`‚úÖ Updated autolinked section in ${path.basename(filePath)}`);
    }

    function findTamerPackages(): DiscoveredPackage[] {
        const packages: DiscoveredPackage[] = [];
        if (!fs.existsSync(nodeModulesPath)) {
            console.warn('‚ö†Ô∏è node_modules directory not found. Skipping autolinking.');
            return [];
        }

        const packageDirs = fs.readdirSync(nodeModulesPath);

        for (const dirName of packageDirs) {
            const fullPath = path.join(nodeModulesPath, dirName);
            const checkPackage = (name: string, packagePath: string) => {
                const tamerConfigPath = path.join(packagePath, 'tamer.json');
                if (fs.existsSync(tamerConfigPath)) {
                    try {
                        const configRaw = fs.readFileSync(tamerConfigPath, 'utf8');
                        const config = JSON.parse(configRaw);
                        if(config.ios){
                            packages.push({ name, config, packagePath });
                        }
                    } catch (e: any) {
                        console.warn(`‚ö†Ô∏è  Skipping package "${name}" due to invalid tamer.json: ${e.message}`);
                    }
                }
            };

            if (dirName.startsWith('@')) {
                try {
                    const scopedDirs = fs.readdirSync(fullPath);
                    for (const scopedDirName of scopedDirs) {
                        const scopedPackagePath = path.join(fullPath, scopedDirName);
                        const name = `${dirName}/${scopedDirName}`;
                        checkPackage(name, scopedPackagePath);
                    }
                } catch (e: any) {
                    console.warn(`‚ö†Ô∏è Could not read scoped package directory ${fullPath}: ${e.message}`);
                }
            } else {
                checkPackage(dirName, fullPath);
            }
        }
        return packages;
    }

    function updatePodfile(packages: DiscoveredPackage[]): void {
        const podfilePath = path.join(iosProjectPath, 'Podfile');
        let scriptContent = `  # This section is automatically generated by Tamer4Lynx.\n  # Manual edits will be overwritten.`;

        const iosPackages = packages.filter(p => p.config.ios);

        if (iosPackages.length > 0) {
            iosPackages.forEach(pkg => {
                const podspecPath = pkg.config.ios?.podspecPath || '.';
                const relativePath = path.relative(iosProjectPath, path.join(pkg.packagePath, podspecPath));
                scriptContent += `\n  pod '${pkg.name}', :path => '${relativePath}'`;
            });
        } else {
            scriptContent += `\n  # No native modules found by Tamer4Lynx autolinker.`;
        }

        updateGeneratedSection(podfilePath, scriptContent.trim(), '# GENERATED AUTOLINK DEPENDENCIES START', '# GENERATED AUTOLINK DEPENDENCIES END');
    }

    function generateSwiftExtensionsFile(packages: DiscoveredPackage[]): void {
        const extensionsPath = path.join(iosProjectPath, appName, 'GeneratedLynxExtensions.swift');

        const modulePackages = packages.filter(p => p.config.ios?.moduleClassName);

        const registrations = modulePackages
            .map(p => {
                const moduleClassName = p.config.ios!.moduleClassName!;
                return `        LynxEnv.sharedInstance().registerModule("${moduleClassName}", for: ${moduleClassName}.self)`;
            })
            .join('\n');

        const swiftContent = `${registrations || '        // No native modules found to register.'}`;

        updateGeneratedSection(extensionsPath, swiftContent, '// GENREATED AUTOLINK REGISTER START', '// GENREATED AUTOLINK REGISTER END');
    }

    // --- Main Execution ---
    function run() {
        console.log('üîé Finding Tamer4Lynx native packages for iOS...');
        const packages = findTamerPackages();

        if (packages.length > 0) {
            console.log(`Found ${packages.length} package(s): ${packages.map(p => p.name).join(', ')}`);
        } else {
            console.log('‚ÑπÔ∏è No Tamer4Lynx native packages found.');
        }

        updatePodfile(packages);
        generateSwiftExtensionsFile(packages);

        console.log('‚ú® Autolinking complete for iOS. Please run `pod install` in the `ios` directory.');
    }

    run();
}

export default autolink;